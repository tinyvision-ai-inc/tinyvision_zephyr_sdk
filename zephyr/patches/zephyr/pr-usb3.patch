From 7d67b107b2386ef39668ceb571ebf8b11a6a7f44 Mon Sep 17 00:00:00 2001
From: Josuah Demangeon <me@josuah.net>
Date: Thu, 8 May 2025 02:55:52 +0200
Subject: [PATCH] usb: device_next: USB 3 support

Introduce definitions to enable USB3 device controllers to be written.
So far, USB 3 support got added to the subsystem, UDC common code, the
Loopback class, UVC class, and the CDC-ACM class.

Signed-off-by: Josuah Demangeon <me@josuah.net>
---
 drivers/usb/udc/Kconfig                       |  10 +
 drivers/usb/udc/udc_virtual.c                 |   8 +-
 include/zephyr/drivers/usb/udc.h              |  45 ++++-
 include/zephyr/usb/bos.h                      |  54 +++++
 include/zephyr/usb/usb_ch9.h                  |  43 +++-
 include/zephyr/usb/usbd.h                     |  44 +++-
 subsys/usb/device_next/Kconfig                |   6 +
 subsys/usb/device_next/class/loopback.c       | 191 +++++++++++++++++-
 subsys/usb/device_next/class/usbd_cdc_acm.c   | 120 ++++++++++-
 subsys/usb/device_next/class/usbd_uvc.c       |  80 +++++++-
 subsys/usb/device_next/usbd_ch9.c             |  38 ++++
 subsys/usb/device_next/usbd_class.c           |  46 ++++-
 subsys/usb/device_next/usbd_config.c          |  24 ++-
 subsys/usb/device_next/usbd_core.c            |  18 ++
 subsys/usb/device_next/usbd_data.ld           |   1 +
 subsys/usb/device_next/usbd_desc.c            |  15 +-
 subsys/usb/device_next/usbd_device.c          |  22 +-
 subsys/usb/device_next/usbd_device.h          |   4 +
 subsys/usb/device_next/usbd_endpoint.c        |   5 +-
 subsys/usb/device_next/usbd_init.c            |  20 ++
 subsys/usb/device_next/usbd_shell.c           |  37 +++-
 .../usb/device_next/boards/native_sim.overlay |   2 +-
 .../subsys/usb/device_next/build_all.overlay  |   2 +-
 tests/subsys/usb/device_next/src/main.c       |  23 ++-
 24 files changed, 823 insertions(+), 35 deletions(-)

diff --git a/drivers/usb/udc/Kconfig b/drivers/usb/udc/Kconfig
index b2c64634315..79352698ba9 100644
--- a/drivers/usb/udc/Kconfig
+++ b/drivers/usb/udc/Kconfig
@@ -11,9 +11,19 @@ menuconfig UDC_DRIVER
 
 if UDC_DRIVER
 
+config UDC_DRIVER_HAS_SUPER_SPEED_SUPPORT
+	bool
+
 config UDC_DRIVER_HAS_HIGH_SPEED_SUPPORT
 	bool
 
+config UDC_DRIVER_SUPER_SPEED_SUPPORT_ENABLED
+	bool "Allow Super-Speed operation"
+	default y if UDC_DRIVER_HAS_SUPER_SPEED_SUPPORT
+	help
+	  Allow Super-Speed capable device to operate at Super-Speed. Disable this
+	  option to force USB 2 only operation.
+
 config UDC_DRIVER_HIGH_SPEED_SUPPORT_ENABLED
 	bool "Allow High-Speed chirp"
 	default y if UDC_DRIVER_HAS_HIGH_SPEED_SUPPORT
diff --git a/drivers/usb/udc/udc_virtual.c b/drivers/usb/udc/udc_virtual.c
index db4f56b11b0..599bf641ee0 100644
--- a/drivers/usb/udc/udc_virtual.c
+++ b/drivers/usb/udc/udc_virtual.c
@@ -491,7 +491,8 @@ static enum udc_bus_speed udc_vrt_device_speed(const struct device *dev)
 	struct udc_data *data = dev->data;
 
 	/* FIXME: get actual device speed */
-	return data->caps.hs ? UDC_BUS_SPEED_HS : UDC_BUS_SPEED_FS;
+	return data->caps.ss ? UDC_BUS_SPEED_SS :
+	       data->caps.hs ? UDC_BUS_SPEED_HS : UDC_BUS_SPEED_FS;
 }
 
 static int udc_vrt_enable(const struct device *dev)
@@ -576,10 +577,13 @@ static int udc_vrt_driver_preinit(const struct device *dev)
 
 	data->caps.rwup = true;
 	data->caps.mps0 = UDC_MPS0_64;
-	if (config->speed_idx == 2) {
+	if (config->speed_idx >= 2) {
 		data->caps.hs = true;
 		mps = 1024;
 	}
+	if (config->speed_idx >= 3) {
+		data->caps.ss = true;
+	}
 
 	for (int i = 0; i < config->num_of_eps; i++) {
 		config->ep_cfg_out[i].caps.out = 1;
diff --git a/include/zephyr/drivers/usb/udc.h b/include/zephyr/drivers/usb/udc.h
index 197cfe60e55..c4057e14991 100644
--- a/include/zephyr/drivers/usb/udc.h
+++ b/include/zephyr/drivers/usb/udc.h
@@ -26,6 +26,7 @@ enum udc_mps0 {
 	UDC_MPS0_16,
 	UDC_MPS0_32,
 	UDC_MPS0_64,
+	UDC_MPS0_512,
 };
 
 /**
@@ -36,6 +37,8 @@ enum udc_mps0 {
 struct udc_device_caps {
 	/** USB high speed capable controller */
 	uint32_t hs : 1;
+	/** USB super speed capable controller */
+	uint32_t ss : 1;
 	/** Controller supports USB remote wakeup */
 	uint32_t rwup : 1;
 	/** Controller performs status OUT stage automatically */
@@ -45,7 +48,7 @@ struct udc_device_caps {
 	/** Controller can detect the state change of USB supply VBUS.*/
 	uint32_t can_detect_vbus : 1;
 	/** Maximum packet size for control endpoint */
-	enum udc_mps0 mps0 : 2;
+	enum udc_mps0 mps0 : 3;
 };
 
 /**
@@ -221,7 +224,7 @@ typedef int (*udc_event_cb_t)(const struct device *dev,
  * @brief UDC driver API
  * This is the mandatory API any USB device controller driver needs to expose
  * with exception of:
- *   device_speed(), test_mode() are only required for HS controllers
+ *   device_speed(), test_mode() are only required for HS and SS controllers
  */
 struct udc_api {
 	enum udc_bus_speed (*device_speed)(const struct device *dev);
@@ -243,6 +246,8 @@ struct udc_api {
 	int (*host_wakeup)(const struct device *dev);
 	int (*set_address)(const struct device *dev,
 			   const uint8_t addr);
+	int (*set_system_exit_latency)(const struct device *dev,
+				       const struct usb_system_exit_latency *sel);
 	int (*test_mode)(const struct device *dev,
 			 const uint8_t mode, const bool dryrun);
 	int (*enable)(const struct device *dev);
@@ -407,7 +412,7 @@ int udc_shutdown(const struct device *dev);
  * @brief Get USB device controller capabilities
  *
  * Obtain the capabilities of the controller
- * such as full speed (FS), high speed (HS), and more.
+ * such as full speed (FS), high speed (HS), super speed (SS), and more.
  *
  * @param[in] dev    Pointer to device struct of the driver instance
  *
@@ -495,6 +500,40 @@ static inline int udc_test_mode(const struct device *dev,
 	return ret;
 }
 
+/**
+ * @brief Set USB3 U1/P1 U2/P2 link latency.
+ *
+ * USB3 defines link latencies values, and the host is expected to configure
+ * these parameters for the device through a SET_SEL command, defined in
+ * USB 3.2 R1 document (section 9.4.12).
+ *
+ * @param[in] dev Pointer to device struct of the driver instance
+ * @param[in] sel Pointer to struct with the latency values from the host
+ *
+ * @return 0 on success, all other values should be treated as error.
+ * @retval -EPERM controller is not enabled (or not initialized)
+ */
+static inline int udc_set_system_exit_latency(const struct device *dev,
+					      const struct usb_system_exit_latency *sel)
+{
+	const struct udc_api *api = dev->api;
+	int ret;
+
+	if (!udc_is_enabled(dev)) {
+		return -EPERM;
+	}
+
+	if (api->set_system_exit_latency != NULL) {
+		api->lock(dev);
+		ret = api->set_system_exit_latency(dev, sel);
+		api->unlock(dev);
+	} else {
+		ret = -ENOTSUP;
+	}
+
+	return ret;
+}
+
 /**
  * @brief Initiate host wakeup procedure.
  *
diff --git a/include/zephyr/usb/bos.h b/include/zephyr/usb/bos.h
index 79dd802bf26..e7e38e85d36 100644
--- a/include/zephyr/usb/bos.h
+++ b/include/zephyr/usb/bos.h
@@ -30,7 +30,10 @@ struct usb_bos_descriptor {
 /** Device capability type codes */
 enum usb_bos_capability_types {
 	USB_BOS_CAPABILITY_EXTENSION = 0x02,
+	USB_BOS_CAPABILITY_SUPERSPEED_USB = 0x03,
 	USB_BOS_CAPABILITY_PLATFORM = 0x05,
+	USB_BOS_CAPABILITY_SUPERSPEED_PLUS = 0x0a,
+	USB_BOS_CAPABILITY_PRECISION_TIME_MEASUREMENT = 0x0b,
 };
 
 /** BOS USB 2.0 extension capability descriptor */
@@ -41,6 +44,12 @@ struct usb_bos_capability_lpm {
 	uint32_t bmAttributes;
 } __packed;
 
+/** Fields for @ref usb_bos_capability_lpm bmAttributes */
+enum usb_bos_attributes {
+	USB_BOS_ATTRIBUTES_LPM = BIT(1),
+	USB_BOS_ATTRIBUTES_BESL = BIT(2),
+};
+
 /** BOS platform capability descriptor */
 struct usb_bos_platform_descriptor {
 	uint8_t bLength;
@@ -50,6 +59,51 @@ struct usb_bos_platform_descriptor {
 	uint8_t PlatformCapabilityUUID[16];
 } __packed;
 
+/** BOS SuperSpeed device capability descriptor */
+struct usb_bos_capability_superspeed_usb {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDevCapabilityType;
+	uint8_t bmAttributes;
+	uint16_t wSpeedsSupported;
+	uint8_t bFunctionnalSupport;
+	uint8_t bU1DevExitLat;
+	uint16_t wU2DevExitLat;
+} __packed;
+
+/** Fields for @ref usb_bos_capability_superspeed_usb bmAttributes */
+enum usb_bos_attributes_superspeed_usb {
+	USB_BOS_ATTRIBUTES_SUPERSPEED_LTM = BIT(1),
+};
+
+/** BOS SuperSpeedPlus device capability descriptor */
+struct usb_bos_capability_superspeedplus {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDevCapabilityType;
+	uint8_t bReserved;
+	uint16_t bmAttributes;
+	uint16_t bFunctionnalSupport;
+	/* Variable size depending on the SSAC value in bmAttributes */
+	uint32_t bmSublinkSpeedAttr[1];
+} __packed;
+
+/** BOS Precision Time Measurement device capability descriptor */
+struct usb_bos_capability_precision_time_measurement {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDevCapabilityType;
+};
+
+/** BOS description of different speeds supported by the device */
+enum usb_bos_speed {
+	USB_BOS_SPEED_LOWSPEED = BIT(0),
+	USB_BOS_SPEED_FULLSPEED = BIT(1),
+	USB_BOS_SPEED_HIGHSPEED = BIT(2),
+	USB_BOS_SPEED_SUPERSPEED_GEN1 = BIT(3),
+	USB_BOS_SPEED_SUPERSPEED_GEN2 = BIT(4),
+};
+
 /** WebUSB specific part of platform capability descriptor */
 struct usb_bos_capability_webusb {
 	uint16_t bcdVersion;
diff --git a/include/zephyr/usb/usb_ch9.h b/include/zephyr/usb/usb_ch9.h
index 0c4a3ac0608..a328425cbc3 100644
--- a/include/zephyr/usb/usb_ch9.h
+++ b/include/zephyr/usb/usb_ch9.h
@@ -105,6 +105,20 @@ static inline bool usb_reqtype_is_to_device(const struct usb_setup_packet *setup
 #define USB_SREQ_GET_INTERFACE		0x0A
 #define USB_SREQ_SET_INTERFACE		0x0B
 #define USB_SREQ_SYNCH_FRAME		0x0C
+/** Additional Request Codes defined in USB 3.2 spec. Table 9-5 */
+#define USB_SREQ_SET_ENCRYPTION		0x0D
+#define USB_SREQ_GET_ENCRYPTION		0x0E
+#define USB_SREQ_SET_HANDSHAKE		0x0F
+#define USB_SREQ_GET_HANDSHAKE		0x10
+#define USB_SREQ_SET_CONNECTION		0x11
+#define USB_SREQ_SET_SECURITY_DATA	0x12
+#define USB_SREQ_GET_SECURITY_DATA	0x13
+#define USB_SREQ_SET_WUSB_DATA		0x14
+#define USB_SREQ_LOOPBACK_DATA_WRITE	0x15
+#define USB_SREQ_LOOPBACK_DATA_READ	0x16
+#define USB_SREQ_SET_INTERFACE_DS	0x17
+#define USB_SREQ_SET_SEL		0x30
+#define USB_SREQ_SET_ISOCH_DELAY	0x31
 
 /** Descriptor Types defined in spec. Table 9-5 */
 #define USB_DESC_DEVICE			1
@@ -121,6 +135,8 @@ static inline bool usb_reqtype_is_to_device(const struct usb_setup_packet *setup
 #define USB_DESC_INTERFACE_ASSOC	11
 #define USB_DESC_BOS			15
 #define USB_DESC_DEVICE_CAPABILITY	16
+#define USB_DESC_ENDPOINT_COMPANION	48
+#define USB_DESC_ISO_ENDPOINT_COMPANION	49
 
 /** Class-Specific Descriptor Types as defined by
  *  USB Common Class Specification
@@ -255,6 +271,23 @@ struct usb_association_descriptor {
 	uint8_t iFunction;
 } __packed;
 
+/** USB Endpoint Companion Descriptor defined in USB3 spec. Table 9-27. */
+struct usb_ss_endpoint_companion_descriptor {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bMaxBurst;
+	uint8_t bmAttributes;
+	uint16_t wBytesPerInterval;
+} __packed;
+
+/** USB3 SET_SEL command payload from the host. Section 9.4.12. */
+struct usb_system_exit_latency {
+	uint8_t u1sel;
+	uint8_t u1pel;
+	uint16_t u2sel;
+	uint16_t u2pel;
+} __packed;
+
 /** USB Standard Configuration Descriptor Characteristics from Table 9-10 */
 #define USB_SCD_RESERVED	BIT(7)
 #define USB_SCD_SELF_POWERED	BIT(6)
@@ -277,7 +310,9 @@ struct usb_association_descriptor {
 #define USB_SRN_2_0			0x0200
 #define USB_SRN_2_0_1			0x0201
 #define USB_SRN_2_1			0x0210
-
+#define USB_SRN_3_0			0x0300
+#define USB_SRN_3_1			0x0310
+#define USB_SRN_3_2			0x0320
 #define USB_DEC_TO_BCD(dec)	((((dec) / 10) << 4) | ((dec) % 10))
 
 /** USB Device release number (bcdDevice Descriptor field) */
@@ -357,9 +392,15 @@ struct usb_association_descriptor {
 /** Calculate full speed isochronous endpoint bInterval from a value in microseconds */
 #define USB_FS_ISO_EP_INTERVAL(us)	CLAMP((ilog2((us) / 1000U) + 1U), 1U, 16U)
 
+/** Calculate super speed interrupt endpoint bInterval from a value in microseconds */
+#define USB_SS_INT_EP_INTERVAL(us)	CLAMP((ilog2((us) / 125U) + 1U), 1U, 16U)
+
 /** Calculate high speed isochronous endpoint bInterval from a value in microseconds */
 #define USB_HS_ISO_EP_INTERVAL(us)	CLAMP((ilog2((us) / 125U) + 1U), 1U, 16U)
 
+/** Calculate super speed isochronous endpoint bInterval from a value in microseconds */
+#define USB_SS_ISO_EP_INTERVAL(us)	CLAMP((ilog2((us) / 125U) + 1U), 1U, 16U)
+
 /** Get endpoint size field from Max Packet Size value */
 #define USB_MPS_EP_SIZE(mps)		((mps) & BIT_MASK(11))
 
diff --git a/include/zephyr/usb/usbd.h b/include/zephyr/usb/usbd.h
index 029741f076d..d0a9497fe7f 100644
--- a/include/zephyr/usb/usbd.h
+++ b/include/zephyr/usb/usbd.h
@@ -37,11 +37,17 @@ extern "C" {
  * @{
  */
 
+/* 1 if USB device stack is compiled with Super-Speed support */
+#define USBD_SUPPORTS_SUPER_SPEED IS_EQ(CONFIG_USBD_MAX_SPEED, 2)
+
 /* 1 if USB device stack is compiled with High-Speed support */
-#define USBD_SUPPORTS_HIGH_SPEED IS_EQ(CONFIG_USBD_MAX_SPEED, 1)
+#define USBD_SUPPORTS_HIGH_SPEED						\
+	UTIL_OR(IS_EQ(CONFIG_USBD_MAX_SPEED, 1), USBD_SUPPORTS_SUPER_SPEED)
 
 /* Maximum bulk max packet size the stack supports */
-#define USBD_MAX_BULK_MPS COND_CODE_1(USBD_SUPPORTS_HIGH_SPEED, (512), (64))
+#define USBD_MAX_BULK_MPS							\
+	COND_CODE_1(USBD_SUPPORTS_SUPER_SPEED, (1024),				\
+		    (COND_CODE_1(USBD_SUPPORTS_HIGH_SPEED, (512), (64))))
 
 /*
  * The length of the string descriptor (bLength) is calculated from the
@@ -295,6 +301,8 @@ struct usbd_context {
 	sys_slist_t fs_configs;
 	/** slist to manage High-Speed device configurations */
 	sys_slist_t hs_configs;
+	/** slist to manage Super-Speed device configurations */
+	sys_slist_t ss_configs;
 	/** dlist to manage vendor requests with recipient device */
 	sys_dlist_t vreqs;
 	/** Status of the USB device support */
@@ -303,6 +311,8 @@ struct usbd_context {
 	void *fs_desc;
 	/** Pointer to High-Speed device descriptor */
 	void *hs_desc;
+	/** Pointer to Super-Speed device descriptor */
+	void *ss_desc;
 };
 
 /**
@@ -504,6 +514,25 @@ static inline void *usbd_class_get_private(const struct usbd_class_data *const c
 		.bNumConfigurations = 0,				\
 	};								\
 	))								\
+	IF_ENABLED(USBD_SUPPORTS_SUPER_SPEED, (				\
+	static struct usb_device_descriptor				\
+	ss_desc_##device_name = {					\
+		.bLength = sizeof(struct usb_device_descriptor),	\
+		.bDescriptorType = USB_DESC_DEVICE,			\
+		.bcdUSB = sys_cpu_to_le16(USB_SRN_3_2),			\
+		.bDeviceClass = USB_BCC_MISCELLANEOUS,			\
+		.bDeviceSubClass = 2,					\
+		.bDeviceProtocol = 1,					\
+		.bMaxPacketSize0 = 9,					\
+		.idVendor = vid,					\
+		.idProduct = pid,					\
+		.bcdDevice = sys_cpu_to_le16(USB_BCD_DRN),		\
+		.iManufacturer = 0,					\
+		.iProduct = 0,						\
+		.iSerialNumber = 0,					\
+		.bNumConfigurations = 0,				\
+	};								\
+	))								\
 	static STRUCT_SECTION_ITERABLE(usbd_context, device_name) = {	\
 		.name = STRINGIFY(device_name),				\
 		.dev = udc_dev,						\
@@ -511,6 +540,9 @@ static inline void *usbd_class_get_private(const struct usbd_class_data *const c
 		IF_ENABLED(USBD_SUPPORTS_HIGH_SPEED, (			\
 		.hs_desc = &hs_desc_##device_name,			\
 		))							\
+		IF_ENABLED(USBD_SUPPORTS_SUPER_SPEED, (			\
+		.ss_desc = &ss_desc_##device_name,			\
+		))							\
 	}
 
 /**
@@ -762,7 +794,13 @@ static inline void *usbd_class_get_private(const struct usbd_class_data *const c
 	static STRUCT_SECTION_ITERABLE_ALTERNATE(				\
 		usbd_class_hs, usbd_class_node, class_name##_hs) = {		\
 		.c_data = &class_name,						\
-	}									\
+	};									\
+	))									\
+	IF_ENABLED(USBD_SUPPORTS_SUPER_SPEED, (					\
+	static STRUCT_SECTION_ITERABLE_ALTERNATE(				\
+		usbd_class_ss, usbd_class_node, class_name##_ss) = {		\
+		.c_data = &class_name,						\
+	};									\
 	))
 
 /** @brief Helper to declare request table of usbd_cctx_vendor_req
diff --git a/subsys/usb/device_next/Kconfig b/subsys/usb/device_next/Kconfig
index 18b6860b0e6..8c1f469bfd9 100644
--- a/subsys/usb/device_next/Kconfig
+++ b/subsys/usb/device_next/Kconfig
@@ -18,9 +18,14 @@ source "subsys/logging/Kconfig.template.log_config"
 
 choice USBD_MAX_SPEED_CHOICE
 	prompt "Max supported connection speed"
+	default USBD_MAX_SPEED_SUPER if UDC_DRIVER_HAS_SUPER_SPEED_SUPPORT
 	default USBD_MAX_SPEED_HIGH if UDC_DRIVER_HAS_HIGH_SPEED_SUPPORT
 	default USBD_MAX_SPEED_FULL
 
+config USBD_MAX_SPEED_SUPER
+	bool "Super-Speed"
+	depends on UDC_DRIVER_HAS_SUPER_SPEED_SUPPORT
+
 config USBD_MAX_SPEED_HIGH
 	bool "High-Speed"
 	depends on UDC_DRIVER_HAS_HIGH_SPEED_SUPPORT
@@ -35,6 +40,7 @@ config USBD_MAX_SPEED
 	int
 	default 0 if USBD_MAX_SPEED_FULL
 	default 1 if USBD_MAX_SPEED_HIGH
+	default 2 if USBD_MAX_SPEED_SUPER
 
 config USBD_BOS_SUPPORT
 	bool "USB device BOS support"
diff --git a/subsys/usb/device_next/class/loopback.c b/subsys/usb/device_next/class/loopback.c
index 85896cd549e..8dcc215d685 100644
--- a/subsys/usb/device_next/class/loopback.c
+++ b/subsys/usb/device_next/class/loopback.c
@@ -48,15 +48,31 @@ struct loopback_desc {
 	struct usb_ep_descriptor if0_in_ep;
 	struct usb_ep_descriptor if0_hs_out_ep;
 	struct usb_ep_descriptor if0_hs_in_ep;
+	struct usb_ep_descriptor if0_ss_out_ep;
+	struct usb_ss_endpoint_companion_descriptor if0_ss_out_ep_co;
+	struct usb_ep_descriptor if0_ss_in_ep;
+	struct usb_ss_endpoint_companion_descriptor if0_ss_in_ep_co;
 	struct usb_if_descriptor if1;
 	struct usb_ep_descriptor if1_int_out_ep;
 	struct usb_ep_descriptor if1_int_in_ep;
+	struct usb_ep_descriptor if1_int_ss_out_ep;
+	struct usb_ss_endpoint_companion_descriptor if1_int_ss_out_ep_co;
+	struct usb_ep_descriptor if1_int_ss_in_ep;
+	struct usb_ss_endpoint_companion_descriptor if1_int_ss_in_ep_co;
 	struct usb_if_descriptor if2_0;
 	struct usb_ep_descriptor if2_0_iso_in_ep;
 	struct usb_ep_descriptor if2_0_iso_out_ep;
+	struct usb_ep_descriptor if2_0_iso_ss_in_ep;
+	struct usb_ss_endpoint_companion_descriptor if2_0_iso_ss_in_ep_co;
+	struct usb_ep_descriptor if2_0_iso_ss_out_ep;
+	struct usb_ss_endpoint_companion_descriptor if2_0_iso_ss_out_ep_co;
 	struct usb_if_descriptor if2_1;
 	struct usb_ep_descriptor if2_1_iso_in_ep;
 	struct usb_ep_descriptor if2_1_iso_out_ep;
+	struct usb_ep_descriptor if2_1_iso_ss_in_ep;
+	struct usb_ss_endpoint_companion_descriptor if2_1_iso_ss_in_ep_co;
+	struct usb_ep_descriptor if2_1_iso_ss_out_ep;
+	struct usb_ss_endpoint_companion_descriptor if2_1_iso_ss_out_ep_co;
 	struct usb_desc_header nil_desc;
 };
 
@@ -64,6 +80,7 @@ struct lb_data {
 	struct loopback_desc *const desc;
 	const struct usb_desc_header **const fs_desc;
 	const struct usb_desc_header **const hs_desc;
+	const struct usb_desc_header **const ss_desc;
 	atomic_t state;
 };
 
@@ -257,6 +274,9 @@ static void *lb_get_desc(struct usbd_class_data *const c_data,
 	if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
 		return data->hs_desc;
 	}
+	if (speed == USBD_SPEED_SS) {
+		return data->ss_desc;
+	}
 
 	return data->fs_desc;
 }
@@ -365,6 +385,44 @@ static struct loopback_desc lb_desc_##x = {					\
 		.bInterval = 0x00,						\
 	},									\
 										\
+	/* Data Endpoint OUT */							\
+	.if0_ss_out_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x01,					\
+		.bmAttributes = USB_EP_TYPE_BULK,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024),			\
+		.bInterval = 0x00,						\
+	},									\
+										\
+	/* Data Endpoint Companion OUT */					\
+	.if0_ss_out_ep_co = {							\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
+	/* Data Endpoint IN */							\
+	.if0_hs_in_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x81,					\
+		.bmAttributes = USB_EP_TYPE_BULK,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024),			\
+		.bInterval = 0x00,						\
+	},									\
+										\
+	/* Data Endpoint Companion IN */					\
+	.if0_ss_in_ep_co = {							\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
 	/* Interface descriptor 1 */						\
 	.if1 = {								\
 		.bLength = sizeof(struct usb_if_descriptor),			\
@@ -388,7 +446,7 @@ static struct loopback_desc lb_desc_##x = {					\
 		.bInterval = 0x01,						\
 	},									\
 										\
-	/* Interrupt Interrupt Endpoint IN */					\
+	/* Interface Interrupt Endpoint IN */					\
 	.if1_int_in_ep = {							\
 		.bLength = sizeof(struct usb_ep_descriptor),			\
 		.bDescriptorType = USB_DESC_ENDPOINT,				\
@@ -398,6 +456,44 @@ static struct loopback_desc lb_desc_##x = {					\
 		.bInterval = 0x01,						\
 	},									\
 										\
+	/* Interface Interrupt Endpoint OUT */					\
+	.if1_int_ss_out_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x02,					\
+		.bmAttributes = USB_EP_TYPE_INTERRUPT,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024),			\
+		.bInterval = 0x01,						\
+	},									\
+										\
+	/* Interface Interrupt Endpoint Companion OUT */			\
+	.if1_int_ss_out_ep_co = {						\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
+	/* Interface Interrupt Endpoint IN */					\
+	.if1_int_ss_in_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x82,					\
+		.bmAttributes = USB_EP_TYPE_INTERRUPT,				\
+		.wMaxPacketSize = sys_cpu_to_le16(64),				\
+		.bInterval = 0x01,						\
+	},									\
+										\
+	/* Interface Interrupt Endpoint Companion IN */				\
+	.if1_int_ss_in_ep_co = {						\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
 	.if2_0 = {								\
 		.bLength = sizeof(struct usb_if_descriptor),			\
 		.bDescriptorType = USB_DESC_INTERFACE,				\
@@ -428,6 +524,40 @@ static struct loopback_desc lb_desc_##x = {					\
 		.bInterval = LB_ISO_EP_INTERVAL,				\
 	},									\
 										\
+	.if2_0_iso_ss_in_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x83,					\
+		.bmAttributes = USB_EP_TYPE_ISO,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024),			\
+		.bInterval = LB_ISO_EP_INTERVAL,				\
+	},									\
+										\
+	.if2_0_iso_ss_in_ep_co = {						\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
+	.if2_0_iso_ss_out_ep = {						\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x03,					\
+		.bmAttributes = USB_EP_TYPE_ISO,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024),			\
+		.bInterval = LB_ISO_EP_INTERVAL,				\
+	},									\
+										\
+	.if2_0_iso_ss_out_ep_co = {						\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
 	.if2_1 = {								\
 		.bLength = sizeof(struct usb_if_descriptor),			\
 		.bDescriptorType = USB_DESC_INTERFACE,				\
@@ -458,6 +588,40 @@ static struct loopback_desc lb_desc_##x = {					\
 		.bInterval = LB_ISO_EP_INTERVAL,				\
 	},									\
 										\
+	.if2_1_iso_ss_in_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x83,					\
+		.bmAttributes = USB_EP_TYPE_ISO,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024),			\
+		.bInterval = LB_ISO_EP_INTERVAL,				\
+	},									\
+										\
+	.if2_1_iso_ss_in_ep_co = {						\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
+	.if2_1_iso_ss_out_ep = {						\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x03,					\
+		.bmAttributes = USB_EP_TYPE_ISO,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024),			\
+		.bInterval = LB_ISO_EP_INTERVAL,				\
+	},									\
+										\
+	.if2_1_iso_ss_out_ep_co = {						\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
 	/* Termination descriptor */						\
 	.nil_desc = {								\
 		.bLength = 0,							\
@@ -497,14 +661,37 @@ const static struct usb_desc_header *lb_hs_desc_##x[] = {			\
 	(struct usb_desc_header *) &lb_desc_##x.if2_1_iso_in_ep,		\
 	(struct usb_desc_header *) &lb_desc_##x.if2_1_iso_out_ep,		\
 	(struct usb_desc_header *) &lb_desc_##x.nil_desc,			\
+};										\
+										\
+const static struct usb_desc_header *lb_ss_desc_##x[] = {			\
+	(struct usb_desc_header *) &lb_desc_##x.iad,				\
+	(struct usb_desc_header *) &lb_desc_##x.if0,				\
+	(struct usb_desc_header *) &lb_desc_##x.if0_ss_in_ep,			\
+	(struct usb_desc_header *) &lb_desc_##x.if0_ss_out_ep,			\
+	(struct usb_desc_header *) &lb_desc_##x.if1,				\
+	(struct usb_desc_header *) &lb_desc_##x.if1_int_ss_in_ep,		\
+	(struct usb_desc_header *) &lb_desc_##x.if1_int_ss_in_ep_co,		\
+	(struct usb_desc_header *) &lb_desc_##x.if1_int_ss_out_ep,		\
+	(struct usb_desc_header *) &lb_desc_##x.if1_int_ss_out_ep_co,		\
+	(struct usb_desc_header *) &lb_desc_##x.if2_0,				\
+	(struct usb_desc_header *) &lb_desc_##x.if2_0_iso_ss_in_ep,		\
+	(struct usb_desc_header *) &lb_desc_##x.if2_0_iso_ss_in_ep_co,		\
+	(struct usb_desc_header *) &lb_desc_##x.if2_0_iso_ss_out_ep,		\
+	(struct usb_desc_header *) &lb_desc_##x.if2_0_iso_ss_out_ep_co,		\
+	(struct usb_desc_header *) &lb_desc_##x.if2_1,				\
+	(struct usb_desc_header *) &lb_desc_##x.if2_1_iso_ss_in_ep,		\
+	(struct usb_desc_header *) &lb_desc_##x.if2_1_iso_ss_in_ep_co,		\
+	(struct usb_desc_header *) &lb_desc_##x.if2_1_iso_ss_out_ep,		\
+	(struct usb_desc_header *) &lb_desc_##x.if2_1_iso_ss_out_ep_co,		\
+	(struct usb_desc_header *) &lb_desc_##x.nil_desc,			\
 };
 
-
 #define DEFINE_LOOPBACK_CLASS_DATA(x, _)					\
 	static struct lb_data lb_data_##x = {					\
 		.desc = &lb_desc_##x,						\
 		.fs_desc = lb_fs_desc_##x,					\
 		.hs_desc = lb_hs_desc_##x,					\
+		.ss_desc = lb_ss_desc_##x,					\
 	};									\
 										\
 	USBD_DEFINE_CLASS(loopback_##x, &lb_api, &lb_data_##x, &lb_vregs);
diff --git a/subsys/usb/device_next/class/usbd_cdc_acm.c b/subsys/usb/device_next/class/usbd_cdc_acm.c
index b75705d1293..dcc30cb687e 100644
--- a/subsys/usb/device_next/class/usbd_cdc_acm.c
+++ b/subsys/usb/device_next/class/usbd_cdc_acm.c
@@ -39,6 +39,7 @@ LOG_MODULE_REGISTER(usbd_cdc_acm, CONFIG_USBD_CDC_ACM_LOG_LEVEL);
 #define CDC_ACM_INTERVAL_DEFAULT	10000UL
 #define CDC_ACM_FS_INT_EP_INTERVAL	USB_FS_INT_EP_INTERVAL(10000U)
 #define CDC_ACM_HS_INT_EP_INTERVAL	USB_HS_INT_EP_INTERVAL(10000U)
+#define CDC_ACM_SS_INT_EP_INTERVAL	USB_SS_INT_EP_INTERVAL(10000U)
 
 #define CDC_ACM_CLASS_ENABLED		0
 #define CDC_ACM_CLASS_SUSPENDED		1
@@ -72,6 +73,15 @@ struct usbd_cdc_acm_desc {
 	struct usb_ep_descriptor if1_hs_out_ep;
 #endif
 
+#if USBD_SUPPORTS_SUPER_SPEED
+	struct usb_ep_descriptor if0_ss_int_ep;
+	struct usb_ss_endpoint_companion_descriptor if0_ss_int_ep_co;
+	struct usb_ep_descriptor if1_ss_in_ep;
+	struct usb_ss_endpoint_companion_descriptor if1_ss_in_ep_co;
+	struct usb_ep_descriptor if1_ss_out_ep;
+	struct usb_ss_endpoint_companion_descriptor if1_ss_out_ep_co;
+#endif
+
 	struct usb_desc_header nil_desc;
 };
 
@@ -84,6 +94,7 @@ struct cdc_acm_uart_config {
 	struct usbd_cdc_acm_desc *const desc;
 	const struct usb_desc_header **const fs_desc;
 	const struct usb_desc_header **const hs_desc;
+	const struct usb_desc_header **const ss_desc;
 };
 
 struct cdc_acm_uart_data {
@@ -224,6 +235,12 @@ static uint8_t cdc_acm_get_int_in(struct usbd_class_data *const c_data)
 	}
 #endif
 
+#if USBD_SUPPORTS_SUPER_SPEED
+	if (usbd_bus_speed(usbd_class_get_ctx(c_data)) == USBD_SPEED_SS) {
+		return desc->if0_ss_int_ep.bEndpointAddress;
+	}
+#endif
+
 	return desc->if0_int_ep.bEndpointAddress;
 }
 
@@ -239,6 +256,12 @@ static uint8_t cdc_acm_get_bulk_in(struct usbd_class_data *const c_data)
 	}
 #endif
 
+#if USBD_SUPPORTS_SUPER_SPEED
+	if (usbd_bus_speed(usbd_class_get_ctx(c_data)) == USBD_SPEED_SS) {
+		return desc->if1_ss_in_ep.bEndpointAddress;
+	}
+#endif
+
 	return desc->if1_in_ep.bEndpointAddress;
 }
 
@@ -254,6 +277,12 @@ static uint8_t cdc_acm_get_bulk_out(struct usbd_class_data *const c_data)
 	}
 #endif
 
+#if USBD_SUPPORTS_SUPER_SPEED
+	if (usbd_bus_speed(usbd_class_get_ctx(c_data)) == USBD_SPEED_SS) {
+		return desc->if1_ss_out_ep.bEndpointAddress;
+	}
+#endif
+
 	return desc->if1_out_ep.bEndpointAddress;
 }
 
@@ -265,6 +294,10 @@ static size_t cdc_acm_get_bulk_mps(struct usbd_class_data *const c_data)
 	    usbd_bus_speed(uds_ctx) == USBD_SPEED_HS) {
 		return 512U;
 	}
+	if (USBD_SUPPORTS_SUPER_SPEED &&
+	    usbd_bus_speed(uds_ctx) == USBD_SPEED_SS) {
+		return 1024U;
+	}
 
 	return 64U;
 }
@@ -405,6 +438,9 @@ static void *usbd_cdc_acm_get_desc(struct usbd_class_data *const c_data,
 	if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
 		return cfg->hs_desc;
 	}
+	if (USBD_SUPPORTS_SUPER_SPEED && speed == USBD_SPEED_SS) {
+		return cfg->ss_desc;
+	}
 
 	return cfg->fs_desc;
 }
@@ -1192,6 +1228,58 @@ struct usbd_class_api usbd_cdc_acm_api = {
 		.bInterval = 0,							\
 	},
 
+#define CDC_ACM_DEFINE_DESCRIPTOR_SS(n)						\
+	.if0_ss_int_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x81,					\
+		.bmAttributes = USB_EP_TYPE_INTERRUPT,				\
+		.wMaxPacketSize = sys_cpu_to_le16(CDC_ACM_DEFAULT_INT_EP_MPS),	\
+		.bInterval = CDC_ACM_SS_INT_EP_INTERVAL,			\
+	},									\
+										\
+	.if0_ss_int_ep_co = {							\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 0,							\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
+	.if1_ss_in_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x82,					\
+		.bmAttributes = USB_EP_TYPE_BULK,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024U),			\
+		.bInterval = 0,							\
+	},									\
+										\
+	.if1_ss_in_ep_co = {							\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},									\
+										\
+	.if1_ss_out_ep = {							\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x01,					\
+		.bmAttributes = USB_EP_TYPE_BULK,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024U),			\
+		.bInterval = 0,							\
+	},									\
+										\
+	.if1_ss_out_ep_co = {							\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
+	},
+
 #define CDC_ACM_DEFINE_DESCRIPTOR(n)						\
 static struct usbd_cdc_acm_desc cdc_acm_desc_##n = {				\
 	.iad = {								\
@@ -1291,6 +1379,10 @@ static struct usbd_cdc_acm_desc cdc_acm_desc_##n = {				\
 		    (CDC_ACM_DEFINE_DESCRIPTOR_HS(n)),				\
 		    ())								\
 										\
+	COND_CODE_1(USBD_SUPPORTS_SUPER_SPEED,					\
+		    (CDC_ACM_DEFINE_DESCRIPTOR_SS(n)),				\
+		    ())								\
+										\
 	.nil_desc = {								\
 		.bLength = 0,							\
 		.bDescriptorType = 0,						\
@@ -1326,6 +1418,24 @@ const static struct usb_desc_header *cdc_acm_hs_desc_##n[] = {			\
 	(struct usb_desc_header *) &cdc_acm_desc_##n.nil_desc,			\
 };
 
+#define CDC_ACM_DEFINE_SS_DESC_HEADER(n)					\
+const static struct usb_desc_header *cdc_acm_ss_desc_##n[] = {			\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.iad,			\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if0,			\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if0_header,		\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if0_cm,			\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if0_acm,			\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if0_union,			\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if0_ss_int_ep,		\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if0_ss_int_ep_co,		\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if1,			\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if1_ss_in_ep,		\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if1_ss_in_ep_co,		\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if1_ss_out_ep,		\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.if1_ss_out_ep_co,		\
+	(struct usb_desc_header *) &cdc_acm_desc_##n.nil_desc,			\
+};
+
 #define USBD_CDC_ACM_DT_DEVICE_DEFINE(n)					\
 	BUILD_ASSERT(DT_INST_ON_BUS(n, usb),					\
 		     "node " DT_NODE_PATH(DT_DRV_INST(n))			\
@@ -1334,11 +1444,13 @@ const static struct usb_desc_header *cdc_acm_hs_desc_##n[] = {			\
 	CDC_ACM_DEFINE_DESCRIPTOR(n);						\
 	COND_CODE_1(USBD_SUPPORTS_HIGH_SPEED,					\
 		    (CDC_ACM_DEFINE_HS_DESC_HEADER(n)),				\
+		    ())								\
+	COND_CODE_1(USBD_SUPPORTS_SUPER_SPEED,					\
+		    (CDC_ACM_DEFINE_SS_DESC_HEADER(n)),				\
 		    ())								\
 										\
-	USBD_DEFINE_CLASS(cdc_acm_##n,						\
-			  &usbd_cdc_acm_api,					\
-			  (void *)DEVICE_DT_GET(DT_DRV_INST(n)), NULL);		\
+	USBD_DEFINE_CLASS(cdc_acm_##n, &usbd_cdc_acm_api,			\
+			  (void *)DEVICE_DT_INST_GET(n), NULL);			\
 										\
 	IF_ENABLED(DT_INST_NODE_HAS_PROP(n, label), (				\
 	USBD_DESC_STRING_DEFINE(cdc_acm_if_desc_data_##n,			\
@@ -1358,6 +1470,8 @@ const static struct usb_desc_header *cdc_acm_hs_desc_##n[] = {			\
 		.fs_desc = cdc_acm_fs_desc_##n,					\
 		.hs_desc = COND_CODE_1(USBD_SUPPORTS_HIGH_SPEED,		\
 				       (cdc_acm_hs_desc_##n,), (NULL,))		\
+		.ss_desc = COND_CODE_1(USBD_SUPPORTS_HIGH_SPEED,		\
+				       (cdc_acm_ss_desc_##n,), (NULL,))		\
 	};									\
 										\
 	static struct cdc_acm_uart_data uart_data_##n = {			\
diff --git a/subsys/usb/device_next/class/usbd_uvc.c b/subsys/usb/device_next/class/usbd_uvc.c
index 556627aff85..0099b52cdb2 100644
--- a/subsys/usb/device_next/class/usbd_uvc.c
+++ b/subsys/usb/device_next/class/usbd_uvc.c
@@ -34,6 +34,7 @@ LOG_MODULE_REGISTER(usbd_uvc, CONFIG_USBD_VIDEO_LOG_LEVEL);
 #define UVC_VBUF_DONE 1
 #define UVC_MAX_FS_DESC (CONFIG_USBD_VIDEO_MAX_FORMATS + 13)
 #define UVC_MAX_HS_DESC (CONFIG_USBD_VIDEO_MAX_FORMATS + 13)
+#define UVC_MAX_SS_DESC (CONFIG_USBD_VIDEO_MAX_FORMATS + 14)
 #define UVC_IDX_VC_UNIT 3
 #define UVC_MAX_HEADER_LENGTH 0xff
 
@@ -92,6 +93,8 @@ struct uvc_desc {
 	struct uvc_color_descriptor if1_color;
 	struct usb_ep_descriptor if1_ep_fs;
 	struct usb_ep_descriptor if1_ep_hs;
+	struct usb_ep_descriptor if1_ep_ss;
+	struct usb_ss_endpoint_companion_descriptor if1_ep_ss_co;
 };
 
 struct uvc_data {
@@ -122,6 +125,7 @@ struct uvc_data {
 	/* Index where newly generated descriptors are appened */
 	unsigned int fs_desc_idx;
 	unsigned int hs_desc_idx;
+	unsigned int ss_desc_idx;
 	unsigned int fmt_desc_idx;
 	/* UVC error from latest request */
 	uint8_t err;
@@ -139,6 +143,7 @@ struct uvc_config {
 	/* Array of pointers to descriptors sent to the USB device stack and the host */
 	struct usb_desc_header **fs_desc;
 	struct usb_desc_header **hs_desc;
+	struct usb_desc_header **ss_desc;
 };
 
 /* Specialized version of UDC net_buf metadata with extra fields */
@@ -435,6 +440,11 @@ static uint8_t uvc_get_bulk_in(const struct device *dev)
 	struct usbd_context *uds_ctx = usbd_class_get_ctx(cfg->c_data);
 	struct uvc_desc *desc = cfg->desc;
 
+	if (USBD_SUPPORTS_SUPER_SPEED &&
+	    usbd_bus_speed(uds_ctx) == USBD_SPEED_SS) {
+		return desc->if1_ep_ss.bEndpointAddress;
+	}
+
 	if (USBD_SUPPORTS_HIGH_SPEED &&
 	    usbd_bus_speed(uds_ctx) == USBD_SPEED_HS) {
 		return desc->if1_ep_hs.bEndpointAddress;
@@ -447,6 +457,11 @@ static size_t uvc_get_bulk_mps(struct usbd_class_data *const c_data)
 {
 	struct usbd_context *uds_ctx = usbd_class_get_ctx(c_data);
 
+	if (USBD_SUPPORTS_SUPER_SPEED &&
+	    usbd_bus_speed(uds_ctx) == USBD_SPEED_SS) {
+		return 1024U;
+	}
+
 	if (USBD_SUPPORTS_HIGH_SPEED &&
 	    usbd_bus_speed(uds_ctx) == USBD_SPEED_HS) {
 		return 512U;
@@ -1343,6 +1358,11 @@ static void *uvc_get_desc(struct usbd_class_data *const c_data, const enum usbd_
 	const struct uvc_config *const cfg = dev->config;
 	struct uvc_desc *desc = cfg->desc;
 
+	if (USBD_SUPPORTS_SUPER_SPEED && speed == USBD_SPEED_SS) {
+		desc->if1_hdr.bEndpointAddress = desc->if1_ep_ss.bEndpointAddress;
+		return cfg->ss_desc;
+	}
+
 	if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
 		desc->if1_hdr.bEndpointAddress = desc->if1_ep_hs.bEndpointAddress;
 		return cfg->hs_desc;
@@ -1353,7 +1373,7 @@ static void *uvc_get_desc(struct usbd_class_data *const c_data, const enum usbd_
 }
 
 static int uvc_assign_desc(const struct device *dev, void *const desc,
-			   const bool add_to_fs, const bool add_to_hs)
+			   const bool add_to_fs, const bool add_to_hs, const bool add_to_ss)
 {
 	const struct uvc_config *cfg = dev->config;
 	struct uvc_data *data = dev->data;
@@ -1377,6 +1397,16 @@ static int uvc_assign_desc(const struct device *dev, void *const desc,
 		cfg->hs_desc[data->hs_desc_idx] = (struct usb_desc_header *)&nil_desc;
 	}
 
+	if (add_to_ss) {
+		if (data->ss_desc_idx + 1 >= UVC_MAX_SS_DESC) {
+			goto err;
+		}
+		cfg->ss_desc[data->ss_desc_idx] = (struct usb_desc_header *)desc;
+		data->ss_desc_idx++;
+		cfg->ss_desc[data->ss_desc_idx] = (struct usb_desc_header *)&nil_desc;
+	}
+
+
 	return 0;
 err:
 	LOG_ERR("Out of descriptor pointers, raise CONFIG_USBD_VIDEO_MAX_FORMATS above %u",
@@ -1404,7 +1434,7 @@ static union uvc_fmt_desc *uvc_new_fmt_desc(const struct device *dev)
 
 	LOG_DBG("Allocated format/frame descriptor %u (%p)", data->fmt_desc_idx, desc);
 
-	ret = uvc_assign_desc(dev, desc, true, true);
+	ret = uvc_assign_desc(dev, desc, true, true, true);
 	if (ret != 0) {
 		return NULL;
 	}
@@ -1676,7 +1706,7 @@ static int uvc_init(struct usbd_class_data *const c_data)
 		if (prev_pixfmt != cap->pixelformat) {
 			if (prev_pixfmt != 0) {
 				cfg->desc->if1_hdr.wTotalLength += cfg->desc->if1_color.bLength;
-				uvc_assign_desc(dev, &cfg->desc->if1_color, true, true);
+				uvc_assign_desc(dev, &cfg->desc->if1_color, true, true, true);
 			}
 
 			ret = uvc_add_vs_format_desc(dev, &format_desc, cap);
@@ -1701,9 +1731,11 @@ static int uvc_init(struct usbd_class_data *const c_data)
 	}
 
 	cfg->desc->if1_hdr.wTotalLength += cfg->desc->if1_color.bLength;
-	uvc_assign_desc(dev, &cfg->desc->if1_color, true, true);
-	uvc_assign_desc(dev, &cfg->desc->if1_ep_fs, true, false);
-	uvc_assign_desc(dev, &cfg->desc->if1_ep_hs, false, true);
+	uvc_assign_desc(dev, &cfg->desc->if1_color, true, true, true);
+	uvc_assign_desc(dev, &cfg->desc->if1_ep_fs, true, false, false);
+	uvc_assign_desc(dev, &cfg->desc->if1_ep_hs, false, true, false);
+	uvc_assign_desc(dev, &cfg->desc->if1_ep_ss, false, false, true);
+	uvc_assign_desc(dev, &cfg->desc->if1_ep_ss_co, false, false, true);
 
 	cfg->desc->if1_hdr.wTotalLength = sys_cpu_to_le16(cfg->desc->if1_hdr.wTotalLength);
 
@@ -2295,6 +2327,23 @@ static struct uvc_desc uvc_desc_##n = {						\
 		.bmAttributes = USB_EP_TYPE_BULK,				\
 		.wMaxPacketSize = sys_cpu_to_le16(512),				\
 		.bInterval = 0,							\
+	},									\
+										\
+	.if1_ep_ss = {								\
+		.bLength = sizeof(struct usb_ep_descriptor),			\
+		.bDescriptorType = USB_DESC_ENDPOINT,				\
+		.bEndpointAddress = 0x81,					\
+		.bmAttributes = USB_EP_TYPE_BULK,				\
+		.wMaxPacketSize = sys_cpu_to_le16(1024),			\
+		.bInterval = 0,							\
+	},									\
+										\
+	.if1_ep_ss_co = {							\
+		.bLength = sizeof(struct usb_ss_endpoint_companion_descriptor),	\
+		.bDescriptorType = USB_DESC_ENDPOINT_COMPANION,			\
+		.bMaxBurst = 15,						\
+		.bmAttributes = 0x00,						\
+		.wBytesPerInterval = 0x00,					\
 	},									\
 };										\
 										\
@@ -2328,6 +2377,23 @@ struct usb_desc_header *uvc_hs_desc_##n[UVC_MAX_HS_DESC] = {			\
 	/* More pointers are generated here at runtime */			\
 	(struct usb_desc_header *) &uvc_desc_##n.if1_ep_hs,			\
 	(struct usb_desc_header *) NULL,					\
+};										\
+										\
+struct usb_desc_header *uvc_ss_desc_##n[UVC_MAX_SS_DESC] = {			\
+	(struct usb_desc_header *) &uvc_desc_##n.iad,				\
+	(struct usb_desc_header *) &uvc_desc_##n.if0,				\
+	(struct usb_desc_header *) &uvc_desc_##n.if0_hdr,			\
+	(struct usb_desc_header *) &uvc_desc_##n.if0_ct,			\
+	(struct usb_desc_header *) &uvc_desc_##n.if0_su,			\
+	(struct usb_desc_header *) &uvc_desc_##n.if0_pu,			\
+	(struct usb_desc_header *) &uvc_desc_##n.if0_xu,			\
+	(struct usb_desc_header *) &uvc_desc_##n.if0_ot,			\
+	(struct usb_desc_header *) &uvc_desc_##n.if1,				\
+	(struct usb_desc_header *) &uvc_desc_##n.if1_hdr,			\
+	/* More pointers are generated here at runtime */			\
+	(struct usb_desc_header *) &uvc_desc_##n.if1_ep_ss,			\
+	(struct usb_desc_header *) &uvc_desc_##n.if1_ep_ss_co,			\
+	(struct usb_desc_header *) NULL,					\
 };
 
 #define USBD_VIDEO_DT_DEVICE_DEFINE(n)						\
@@ -2341,11 +2407,13 @@ struct usb_desc_header *uvc_hs_desc_##n[UVC_MAX_HS_DESC] = {			\
 		.desc = &uvc_desc_##n,						\
 		.fs_desc = uvc_fs_desc_##n,					\
 		.hs_desc = uvc_hs_desc_##n,					\
+		.ss_desc = uvc_ss_desc_##n,					\
 	};									\
 										\
 	struct uvc_data uvc_data_##n = {					\
 		.fs_desc_idx = 10,						\
 		.hs_desc_idx = 10,						\
+		.ss_desc_idx = 10,						\
 	};									\
 										\
 	DEVICE_DT_INST_DEFINE(n, uvc_preinit, NULL, &uvc_data_##n, &uvc_cfg_##n,\
diff --git a/subsys/usb/device_next/usbd_ch9.c b/subsys/usb/device_next/usbd_ch9.c
index 599eb161178..3cd07cb32dd 100644
--- a/subsys/usb/device_next/usbd_ch9.c
+++ b/subsys/usb/device_next/usbd_ch9.c
@@ -363,6 +363,32 @@ static int sreq_set_feature(struct usbd_context *const uds_ctx)
 	return ret;
 }
 
+static int sreq_set_sel(struct usbd_context *const uds_ctx, struct net_buf *const buf)
+{
+	struct usb_setup_packet *setup = usbd_get_setup_pkt(uds_ctx);
+	struct usb_system_exit_latency sel;
+
+	if (setup->wValue != 0 || setup->wIndex != 0 || setup->wLength != 6) {
+		LOG_ERR("invalid command parameters");
+		errno = -ENOTSUP;
+		return 0;
+	}
+
+	if (buf->len != setup->wLength) {
+		LOG_ERR("actual buffer length %d mis-matching wLength %d", buf->len,
+			 setup->wLength);
+		errno = -ENOTSUP;
+		return 0;
+	}
+
+	memcpy(&sel, buf->data, sizeof(sel));
+	sel.u2sel = sys_le16_to_cpu(sel.u2sel);
+	sel.u2pel = sys_le16_to_cpu(sel.u2pel);
+
+	errno = udc_set_system_exit_latency(uds_ctx->dev, &sel);
+	return 0;
+}
+
 static int std_request_to_device(struct usbd_context *const uds_ctx,
 				 struct net_buf *const buf)
 {
@@ -385,6 +411,12 @@ static int std_request_to_device(struct usbd_context *const uds_ctx,
 	case USB_SREQ_SET_FEATURE:
 		ret = sreq_set_feature(uds_ctx);
 		break;
+	case USB_SREQ_SET_SEL:
+		ret = sreq_set_sel(uds_ctx, buf);
+		break;
+	case USB_SREQ_SET_ISOCH_DELAY:
+		ret = 0;
+		break;
 	default:
 		errno = -ENOTSUP;
 		ret = 0;
@@ -627,6 +659,9 @@ static int sreq_get_desc_dev(struct usbd_context *const uds_ctx,
 	case USBD_SPEED_HS:
 		head = uds_ctx->hs_desc;
 		break;
+	case USBD_SPEED_SS:
+		head = uds_ctx->ss_desc;
+		break;
 	default:
 		errno = -ENOTSUP;
 		return 0;
@@ -755,6 +790,9 @@ static int sreq_get_desc_bos(struct usbd_context *const uds_ctx,
 	case USBD_SPEED_HS:
 		dev_dsc = uds_ctx->hs_desc;
 		break;
+	case USBD_SPEED_SS:
+		dev_dsc = uds_ctx->ss_desc;
+		break;
 	default:
 		errno = -ENOTSUP;
 		return 0;
diff --git a/subsys/usb/device_next/usbd_class.c b/subsys/usb/device_next/usbd_class.c
index ae5f74b5c5d..f99a07a44f9 100644
--- a/subsys/usb/device_next/usbd_class.c
+++ b/subsys/usb/device_next/usbd_class.c
@@ -222,6 +222,13 @@ usbd_class_node_get(const char *name, const enum usbd_speed speed)
 				return c_nd;
 			}
 		}
+	} else if (speed == USBD_SPEED_SS) {
+		STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_ss,
+						 usbd_class_node, c_nd) {
+			if (strcmp(name, c_nd->c_data->name) == 0) {
+				return c_nd;
+			}
+		}
 	}
 
 	LOG_ERR("USB device class %s not found", name);
@@ -359,6 +366,20 @@ int usbd_register_all_classes(struct usbd_context *const uds_ctx,
 {
 	int ret;
 
+	if (USBD_SUPPORTS_SUPER_SPEED && speed == USBD_SPEED_SS) {
+		STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_ss, usbd_class_node, c_nd) {
+			ret = usbd_register_class(uds_ctx, c_nd->c_data->name,
+						  speed, cfg);
+			if (ret) {
+				LOG_ERR("Failed to register %s to SS configuration %u",
+					c_nd->c_data->name, cfg);
+				return ret;
+			}
+		}
+
+		return 0;
+	}
+
 	if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
 		STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_hs, usbd_class_node, c_nd) {
 			if (blocklist != NULL && is_blocklisted(c_nd, blocklist)) {
@@ -431,7 +452,16 @@ int usbd_unregister_class(struct usbd_context *const uds_ctx,
 	/* TODO: The use of atomic here does not make this code thread safe.
 	 * The atomic should be changed to something else.
 	 */
-	if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
+	if (USBD_SUPPORTS_SUPER_SPEED && speed == USBD_SPEED_SS) {
+		STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_ss,
+						 usbd_class_node, i) {
+			if ((i->c_data == c_nd->c_data) &&
+			    atomic_test_bit(&i->state, USBD_CCTX_REGISTERED)) {
+				can_release_data = false;
+				break;
+			}
+		}
+	} else if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
 		STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_hs,
 						 usbd_class_node, i) {
 			if ((i->c_data == c_nd->c_data) &&
@@ -471,6 +501,20 @@ int usbd_unregister_all_classes(struct usbd_context *const uds_ctx,
 {
 	int ret;
 
+	if (USBD_SUPPORTS_SUPER_SPEED && speed == USBD_SPEED_SS) {
+		STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_ss, usbd_class_node, c_nd) {
+			ret = usbd_unregister_class(uds_ctx, c_nd->c_data->name,
+						    speed, cfg);
+			if (ret) {
+				LOG_ERR("Failed to unregister %s to SS configuration %u",
+					c_nd->c_data->name, cfg);
+				return ret;
+			}
+		}
+
+		return 0;
+	}
+
 	if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
 		STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_hs, usbd_class_node, c_nd) {
 			ret = usbd_unregister_class(uds_ctx, c_nd->c_data->name,
diff --git a/subsys/usb/device_next/usbd_config.c b/subsys/usb/device_next/usbd_config.c
index 8a589722e25..66508cf1aa0 100644
--- a/subsys/usb/device_next/usbd_config.c
+++ b/subsys/usb/device_next/usbd_config.c
@@ -24,6 +24,8 @@ static sys_slist_t *usbd_configs(struct usbd_context *uds_ctx,
 		return &uds_ctx->fs_configs;
 	case USBD_SPEED_HS:
 		return &uds_ctx->hs_configs;
+	case USBD_SPEED_SS:
+		return &uds_ctx->ss_configs;
 	default:
 		return NULL;
 	}
@@ -273,12 +275,19 @@ int usbd_add_configuration(struct usbd_context *const uds_ctx,
 	}
 
 	if (speed == USBD_SPEED_HS &&
-	    usbd_caps_speed(uds_ctx) == USBD_SPEED_FS) {
+	    usbd_caps_speed(uds_ctx) < USBD_SPEED_HS) {
 		LOG_ERR("Controller doesn't support HS");
 		ret = -ENOTSUP;
 		goto add_configuration_exit;
 	}
 
+	if (speed == USBD_SPEED_SS &&
+	    usbd_caps_speed(uds_ctx) < USBD_SPEED_SS) {
+		LOG_ERR("Controller doesn't support SS");
+		ret = -ENOTSUP;
+		goto add_configuration_exit;
+	}
+
 	if (desc->bmAttributes & USB_SCD_REMOTE_WAKEUP) {
 		struct udc_device_caps caps = udc_caps(uds_ctx->dev);
 
@@ -291,10 +300,19 @@ int usbd_add_configuration(struct usbd_context *const uds_ctx,
 
 	configs = usbd_configs(uds_ctx, speed);
 	switch (speed) {
+	case USBD_SPEED_SS:
+		SYS_SLIST_FOR_EACH_NODE(&uds_ctx->ss_configs, node) {
+			if (node == &cfg_nd->node) {
+				LOG_ERR("SS config already on FS or HS list");
+				ret = -EINVAL;
+				goto add_configuration_exit;
+			}
+		}
+		break;
 	case USBD_SPEED_HS:
 		SYS_SLIST_FOR_EACH_NODE(&uds_ctx->fs_configs, node) {
 			if (node == &cfg_nd->node) {
-				LOG_ERR("HS config already on FS list");
+				LOG_ERR("HS config already on FS or SS list");
 				ret = -EINVAL;
 				goto add_configuration_exit;
 			}
@@ -303,7 +321,7 @@ int usbd_add_configuration(struct usbd_context *const uds_ctx,
 	case USBD_SPEED_FS:
 		SYS_SLIST_FOR_EACH_NODE(&uds_ctx->hs_configs, node) {
 			if (node == &cfg_nd->node) {
-				LOG_ERR("FS config already on HS list");
+				LOG_ERR("FS config already on HS or SS list");
 				ret = -EINVAL;
 				goto add_configuration_exit;
 			}
diff --git a/subsys/usb/device_next/usbd_core.c b/subsys/usb/device_next/usbd_core.c
index 9f24530fc2c..f13729be322 100644
--- a/subsys/usb/device_next/usbd_core.c
+++ b/subsys/usb/device_next/usbd_core.c
@@ -118,6 +118,9 @@ static int event_handler_bus_reset(struct usbd_context *const uds_ctx)
 	LOG_INF("Actual device speed %u", udc_device_speed(uds_ctx->dev));
 	udc_speed = udc_device_speed(uds_ctx->dev);
 	switch (udc_speed) {
+	case UDC_BUS_SPEED_SS:
+		uds_ctx->status.speed = USBD_SPEED_SS;
+		break;
 	case UDC_BUS_SPEED_HS:
 		uds_ctx->status.speed = USBD_SPEED_HS;
 		break;
@@ -228,6 +231,17 @@ int usbd_device_shutdown_core(struct usbd_context *const uds_ctx)
 	struct usbd_config_node *cfg_nd;
 	int ret;
 
+	if (USBD_SUPPORTS_SUPER_SPEED) {
+		SYS_SLIST_FOR_EACH_CONTAINER(&uds_ctx->ss_configs, cfg_nd, node) {
+			uint8_t cfg_value = usbd_config_get_value(cfg_nd);
+
+			ret = usbd_class_remove_all(uds_ctx, USBD_SPEED_SS, cfg_value);
+			if (ret) {
+				LOG_ERR("Failed to cleanup registered classes, %d", ret);
+			}
+		}
+	}
+
 	if (USBD_SUPPORTS_HIGH_SPEED) {
 		SYS_SLIST_FOR_EACH_CONTAINER(&uds_ctx->hs_configs, cfg_nd, node) {
 			uint8_t cfg_value = usbd_config_get_value(cfg_nd);
@@ -277,6 +291,10 @@ static int usbd_pre_init(void)
 		atomic_set(&c_nd->state, 0);
 		LOG_DBG("\t%p->%p, name %s", c_nd, c_nd->c_data, c_nd->c_data->name);
 	}
+	STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_ss, usbd_class_node, c_nd) {
+		atomic_set(&c_nd->state, 0);
+		LOG_DBG("\t%p->%p, name %s", c_nd, c_nd->c_data, c_nd->c_data->name);
+	}
 
 	return 0;
 }
diff --git a/subsys/usb/device_next/usbd_data.ld b/subsys/usb/device_next/usbd_data.ld
index 2c672d7224f..51bf6aa47ee 100644
--- a/subsys/usb/device_next/usbd_data.ld
+++ b/subsys/usb/device_next/usbd_data.ld
@@ -1,5 +1,6 @@
 #include <zephyr/linker/iterable_sections.h>
 
 ITERABLE_SECTION_RAM(usbd_context, Z_LINK_ITERABLE_SUBALIGN)
+ITERABLE_SECTION_RAM(usbd_class_ss, Z_LINK_ITERABLE_SUBALIGN)
 ITERABLE_SECTION_RAM(usbd_class_fs, Z_LINK_ITERABLE_SUBALIGN)
 ITERABLE_SECTION_RAM(usbd_class_hs, Z_LINK_ITERABLE_SUBALIGN)
diff --git a/subsys/usb/device_next/usbd_desc.c b/subsys/usb/device_next/usbd_desc.c
index f30e4f197cd..a3a49925f55 100644
--- a/subsys/usb/device_next/usbd_desc.c
+++ b/subsys/usb/device_next/usbd_desc.c
@@ -120,11 +120,12 @@ int usbd_desc_remove_all(struct usbd_context *const uds_ctx)
 int usbd_add_descriptor(struct usbd_context *const uds_ctx,
 			struct usbd_desc_node *const desc_nd)
 {
-	struct usb_device_descriptor *hs_desc, *fs_desc;
+	struct usb_device_descriptor *ss_desc, *hs_desc, *fs_desc;
 	int ret = 0;
 
 	usbd_device_lock(uds_ctx);
 
+	ss_desc = uds_ctx->ss_desc;
 	hs_desc = uds_ctx->hs_desc;
 	if (USBD_SUPPORTS_HIGH_SPEED && hs_desc == NULL) {
 		ret = -EPERM;
@@ -176,6 +177,10 @@ int usbd_add_descriptor(struct usbd_context *const uds_ctx,
 				hs_desc->iManufacturer = desc_nd->str.idx;
 			}
 
+			if (USBD_SUPPORTS_SUPER_SPEED) {
+				ss_desc->iManufacturer = desc_nd->str.idx;
+			}
+
 			fs_desc->iManufacturer = desc_nd->str.idx;
 			break;
 		case USBD_DUT_STRING_PRODUCT:
@@ -183,6 +188,10 @@ int usbd_add_descriptor(struct usbd_context *const uds_ctx,
 				hs_desc->iProduct = desc_nd->str.idx;
 			}
 
+			if (USBD_SUPPORTS_SUPER_SPEED) {
+				ss_desc->iManufacturer = desc_nd->str.idx;
+			}
+
 			fs_desc->iProduct = desc_nd->str.idx;
 			break;
 		case USBD_DUT_STRING_SERIAL_NUMBER:
@@ -190,6 +199,10 @@ int usbd_add_descriptor(struct usbd_context *const uds_ctx,
 				hs_desc->iSerialNumber = desc_nd->str.idx;
 			}
 
+			if (USBD_SUPPORTS_SUPER_SPEED) {
+				ss_desc->iSerialNumber = desc_nd->str.idx;
+			}
+
 			fs_desc->iSerialNumber = desc_nd->str.idx;
 			break;
 		default:
diff --git a/subsys/usb/device_next/usbd_device.c b/subsys/usb/device_next/usbd_device.c
index fcb689a5c56..83d7df472e0 100644
--- a/subsys/usb/device_next/usbd_device.c
+++ b/subsys/usb/device_next/usbd_device.c
@@ -29,7 +29,10 @@ enum usbd_speed usbd_caps_speed(const struct usbd_context *const uds_ctx)
 {
 	struct udc_device_caps caps = udc_caps(uds_ctx->dev);
 
-	/* For now, either high speed is supported or not. */
+	if (caps.ss) {
+		return USBD_SPEED_SS;
+	}
+
 	if (caps.hs) {
 		return USBD_SPEED_HS;
 	}
@@ -46,6 +49,8 @@ get_device_descriptor(struct usbd_context *const uds_ctx,
 		return uds_ctx->fs_desc;
 	case USBD_SPEED_HS:
 		return uds_ctx->hs_desc;
+	case USBD_SPEED_SS:
+		return uds_ctx->ss_desc;
 	default:
 		__ASSERT(false, "Not supported speed");
 		return NULL;
@@ -81,7 +86,7 @@ set_bcd_exit:
 int usbd_device_set_vid(struct usbd_context *const uds_ctx,
 			 const uint16_t vid)
 {
-	struct usb_device_descriptor *fs_desc, *hs_desc;
+	struct usb_device_descriptor *fs_desc, *hs_desc, *ss_desc;
 	int ret = 0;
 
 	usbd_device_lock(uds_ctx);
@@ -99,6 +104,9 @@ int usbd_device_set_vid(struct usbd_context *const uds_ctx,
 		hs_desc->idVendor = sys_cpu_to_le16(vid);
 	}
 
+	ss_desc = get_device_descriptor(uds_ctx, USBD_SPEED_SS);
+	ss_desc->idVendor = sys_cpu_to_le16(vid);
+
 set_vid_exit:
 	usbd_device_unlock(uds_ctx);
 	return ret;
@@ -107,7 +115,7 @@ set_vid_exit:
 int usbd_device_set_pid(struct usbd_context *const uds_ctx,
 			 const uint16_t pid)
 {
-	struct usb_device_descriptor *fs_desc, *hs_desc;
+	struct usb_device_descriptor *fs_desc, *hs_desc, *ss_desc;
 	int ret = 0;
 
 	usbd_device_lock(uds_ctx);
@@ -125,6 +133,9 @@ int usbd_device_set_pid(struct usbd_context *const uds_ctx,
 		hs_desc->idProduct = sys_cpu_to_le16(pid);
 	}
 
+	ss_desc = get_device_descriptor(uds_ctx, USBD_SPEED_SS);
+	ss_desc->idProduct = sys_cpu_to_le16(pid);
+
 set_pid_exit:
 	usbd_device_unlock(uds_ctx);
 	return ret;
@@ -133,7 +144,7 @@ set_pid_exit:
 int usbd_device_set_bcd_device(struct usbd_context *const uds_ctx,
 			       const uint16_t bcd)
 {
-	struct usb_device_descriptor *fs_desc, *hs_desc;
+	struct usb_device_descriptor *fs_desc, *hs_desc, *ss_desc;
 	int ret = 0;
 
 	usbd_device_lock(uds_ctx);
@@ -151,6 +162,9 @@ int usbd_device_set_bcd_device(struct usbd_context *const uds_ctx,
 		hs_desc->bcdDevice = sys_cpu_to_le16(bcd);
 	}
 
+	ss_desc = get_device_descriptor(uds_ctx, USBD_SPEED_SS);
+	ss_desc->bcdDevice = sys_cpu_to_le16(bcd);
+
 set_bcd_device_exit:
 	usbd_device_unlock(uds_ctx);
 	return ret;
diff --git a/subsys/usb/device_next/usbd_device.h b/subsys/usb/device_next/usbd_device.h
index 8d29a19e6a9..3f8c60c7d62 100644
--- a/subsys/usb/device_next/usbd_device.h
+++ b/subsys/usb/device_next/usbd_device.h
@@ -47,6 +47,8 @@ static inline uint8_t usbd_get_num_configs(const struct usbd_context *const uds_
 		desc = uds_ctx->fs_desc;
 	} else if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
 		desc = uds_ctx->hs_desc;
+	} else if (speed == USBD_SPEED_SS) {
+		desc = uds_ctx->ss_desc;
 	} else {
 		return 0;
 	}
@@ -72,6 +74,8 @@ static inline void usbd_set_num_configs(struct usbd_context *const uds_ctx,
 		desc = uds_ctx->fs_desc;
 	} else if (USBD_SUPPORTS_HIGH_SPEED && speed == USBD_SPEED_HS) {
 		desc = uds_ctx->hs_desc;
+	} else if (speed == USBD_SPEED_SS) {
+		desc = uds_ctx->ss_desc;
 	} else {
 		return;
 	}
diff --git a/subsys/usb/device_next/usbd_endpoint.c b/subsys/usb/device_next/usbd_endpoint.c
index 1e0ef658d35..f562ff534f2 100644
--- a/subsys/usb/device_next/usbd_endpoint.c
+++ b/subsys/usb/device_next/usbd_endpoint.c
@@ -61,7 +61,7 @@ static void usbd_ep_ctrl_set_zlp(struct usbd_context *const uds_ctx,
 	struct usb_setup_packet *setup = usbd_get_setup_pkt(uds_ctx);
 	struct usb_device_descriptor *desc = uds_ctx->fs_desc;
 	size_t min_len = MIN(setup->wLength, buf->len);
-	uint8_t mps0 = 0;
+	int mps0 = 0;
 
 	switch (usbd_bus_speed(uds_ctx)) {
 	case USBD_SPEED_FS:
@@ -70,6 +70,9 @@ static void usbd_ep_ctrl_set_zlp(struct usbd_context *const uds_ctx,
 	case USBD_SPEED_HS:
 		mps0 = USB_CONTROL_EP_MPS;
 		break;
+	case USBD_SPEED_SS:
+		mps0 = 512;
+		break;
 	default:
 		__ASSERT(false, "Cannot determine bMaxPacketSize0 (unsupported speed)");
 	}
diff --git a/subsys/usb/device_next/usbd_init.c b/subsys/usb/device_next/usbd_init.c
index 021fc8f2fca..01b5a91b10b 100644
--- a/subsys/usb/device_next/usbd_init.c
+++ b/subsys/usb/device_next/usbd_init.c
@@ -172,6 +172,7 @@ static int init_configuration_inst(struct usbd_context *const uds_ctx,
 			ret = assign_ep_addr(uds_ctx->dev, ed,
 					     config_ep_bm, &class_ep_bm);
 			if (ret) {
+				LOG_ERR("Failed to assign endpoint address");
 				return ret;
 			}
 
@@ -272,6 +273,9 @@ static void usbd_init_update_fs_mps0(struct usbd_context *const uds_ctx)
 	case UDC_MPS0_64:
 		desc->bMaxPacketSize0 = 64;
 		break;
+	case UDC_MPS0_512:
+		desc->bMaxPacketSize0 = 9;
+		break;
 	}
 }
 
@@ -281,6 +285,22 @@ int usbd_init_configurations(struct usbd_context *const uds_ctx)
 
 	usbd_init_update_fs_mps0(uds_ctx);
 
+	if (USBD_SUPPORTS_SUPER_SPEED) {
+		SYS_SLIST_FOR_EACH_CONTAINER(&uds_ctx->ss_configs, cfg_nd, node) {
+			int ret;
+
+			ret = init_configuration(uds_ctx, USBD_SPEED_SS, cfg_nd);
+			if (ret) {
+				LOG_ERR("Failed to init SS configuration %u",
+					usbd_config_get_value(cfg_nd));
+				return ret;
+			}
+
+			LOG_INF("SS bNumConfigurations %u",
+				usbd_get_num_configs(uds_ctx, USBD_SPEED_SS));
+		}
+	}
+
 	if (USBD_SUPPORTS_HIGH_SPEED) {
 		SYS_SLIST_FOR_EACH_CONTAINER(&uds_ctx->hs_configs, cfg_nd, node) {
 			int ret;
diff --git a/subsys/usb/device_next/usbd_shell.c b/subsys/usb/device_next/usbd_shell.c
index 4597143e78b..0841aaa32af 100644
--- a/subsys/usb/device_next/usbd_shell.c
+++ b/subsys/usb/device_next/usbd_shell.c
@@ -17,8 +17,10 @@
 /* Default configurations used in the shell context. */
 USBD_CONFIGURATION_DEFINE(config_1_fs, USB_SCD_REMOTE_WAKEUP, 200, NULL);
 USBD_CONFIGURATION_DEFINE(config_1_hs, USB_SCD_REMOTE_WAKEUP, 200, NULL);
+USBD_CONFIGURATION_DEFINE(config_1_ss, USB_SCD_REMOTE_WAKEUP, 200, NULL);
 USBD_CONFIGURATION_DEFINE(config_2_fs, USB_SCD_SELF_POWERED, 200, NULL);
 USBD_CONFIGURATION_DEFINE(config_2_hs, USB_SCD_SELF_POWERED, 200, NULL);
+USBD_CONFIGURATION_DEFINE(config_2_ss, USB_SCD_SELF_POWERED, 200, NULL);
 
 static struct usbd_shell_config {
 	struct usbd_config_node *cfg_nd;
@@ -27,8 +29,10 @@ static struct usbd_shell_config {
 } sh_configs[] = {
 	{.cfg_nd = &config_1_fs, .speed = USBD_SPEED_FS, .name = "FS1",},
 	{.cfg_nd = &config_1_hs, .speed = USBD_SPEED_HS, .name = "HS1",},
+	{.cfg_nd = &config_1_ss, .speed = USBD_SPEED_SS, .name = "SS1",},
 	{.cfg_nd = &config_2_fs, .speed = USBD_SPEED_FS, .name = "FS2",},
 	{.cfg_nd = &config_2_hs, .speed = USBD_SPEED_HS, .name = "HS2",},
+	{.cfg_nd = &config_2_ss, .speed = USBD_SPEED_SS, .name = "SS2",},
 };
 
 static struct usbd_shell_speed {
@@ -37,6 +41,7 @@ static struct usbd_shell_speed {
 } sh_speed[] = {
 	{.speed = USBD_SPEED_FS, .name = "fs",},
 	{.speed = USBD_SPEED_HS, .name = "hs",},
+	{.speed = USBD_SPEED_SS, .name = "ss",},
 };
 
 /* Default string descriptors used in the shell context. */
@@ -148,7 +153,7 @@ static int register_classes(const struct shell *sh)
 	}
 
 	if (!USBD_SUPPORTS_HIGH_SPEED ||
-	    usbd_caps_speed(my_uds_ctx) != USBD_SPEED_HS) {
+	    usbd_caps_speed(my_uds_ctx) < USBD_SPEED_HS) {
 		return 0;
 	}
 
@@ -165,6 +170,24 @@ static int register_classes(const struct shell *sh)
 		shell_print(sh, "dev: register HS %s", c_nd->c_data->name);
 	}
 
+	if (!USBD_SUPPORTS_SUPER_SPEED ||
+	    usbd_caps_speed(my_uds_ctx) < USBD_SPEED_SS) {
+		return 0;
+	}
+
+	STRUCT_SECTION_FOREACH_ALTERNATE(usbd_class_ss, usbd_class_node, c_nd) {
+		err = usbd_register_class(my_uds_ctx, c_nd->c_data->name,
+					  USBD_SPEED_SS, 1);
+		if (err) {
+			shell_error(sh,
+				    "dev: failed to register SS %s (%d)",
+				    c_nd->c_data->name, err);
+			return err;
+		}
+
+		shell_print(sh, "dev: register SS %s", c_nd->c_data->name);
+	}
+
 	return 0;
 }
 
@@ -196,7 +219,17 @@ static int cmd_usbd_default_config(const struct shell *sh,
 		return err;
 	}
 
-	if (usbd_caps_speed(my_uds_ctx) == USBD_SPEED_HS) {
+	if (USBD_SUPPORTS_SUPER_SPEED &&
+	    usbd_caps_speed(my_uds_ctx) >= USBD_SPEED_SS) {
+		err = usbd_add_configuration(my_uds_ctx, USBD_SPEED_SS, &config_1_ss);
+		if (err) {
+			shell_error(sh, "dev: Failed to add SS configuration");
+			return err;
+		}
+	}
+
+	if (USBD_SUPPORTS_HIGH_SPEED &&
+	    usbd_caps_speed(my_uds_ctx) >= USBD_SPEED_HS) {
 		err = usbd_add_configuration(my_uds_ctx, USBD_SPEED_HS, &config_1_hs);
 		if (err) {
 			shell_error(sh, "dev: Failed to add HS configuration");
diff --git a/tests/subsys/usb/device_next/boards/native_sim.overlay b/tests/subsys/usb/device_next/boards/native_sim.overlay
index d352f555c8c..7c18f895ec9 100644
--- a/tests/subsys/usb/device_next/boards/native_sim.overlay
+++ b/tests/subsys/usb/device_next/boards/native_sim.overlay
@@ -13,7 +13,7 @@
 		zephyr_udc0: udc_vrt0 {
 			compatible = "zephyr,udc-virtual";
 			num-bidir-endpoints = <8>;
-			maximum-speed = "high-speed";
+			maximum-speed = "super-speed";
 		};
 	};
 };
diff --git a/tests/subsys/usb/device_next/build_all.overlay b/tests/subsys/usb/device_next/build_all.overlay
index bafd8f94aaa..9f6297976f2 100644
--- a/tests/subsys/usb/device_next/build_all.overlay
+++ b/tests/subsys/usb/device_next/build_all.overlay
@@ -63,7 +63,7 @@
 		zephyr_udc0: udc_vrt0 {
 			compatible = "zephyr,udc-virtual";
 			num-bidir-endpoints = <16>;
-			maximum-speed = "high-speed";
+			maximum-speed = "super-speed";
 		};
 	};
 
diff --git a/tests/subsys/usb/device_next/src/main.c b/tests/subsys/usb/device_next/src/main.c
index 7c04c18544a..088914bcdab 100644
--- a/tests/subsys/usb/device_next/src/main.c
+++ b/tests/subsys/usb/device_next/src/main.c
@@ -25,6 +25,9 @@ USBD_CONFIGURATION_DEFINE(test_hs_config,
 			  USB_SCD_SELF_POWERED | USB_SCD_REMOTE_WAKEUP,
 			  200, NULL);
 
+USBD_CONFIGURATION_DEFINE(test_ss_config,
+			  USB_SCD_SELF_POWERED | USB_SCD_REMOTE_WAKEUP,
+			  200, NULL);
 
 USBD_DESC_LANG_DEFINE(test_lang);
 USBD_DESC_STRING_DEFINE(test_mfg, "ZEPHYR", 1);
@@ -390,8 +393,14 @@ static void *usb_test_enable(void)
 	err = usbd_add_descriptor(&test_usbd, &test_sn);
 	zassert_equal(err, 0, "Failed to initialize descriptor (%d)", err);
 
+	if (USBD_SUPPORTS_SUPER_SPEED &&
+	    usbd_caps_speed(&test_usbd) >= USBD_SPEED_SS) {
+		err = usbd_add_configuration(&test_usbd, USBD_SPEED_SS, &test_ss_config);
+		zassert_equal(err, 0, "Failed to add configuration (%d)");
+	}
+
 	if (USBD_SUPPORTS_HIGH_SPEED &&
-	    usbd_caps_speed(&test_usbd) == USBD_SPEED_HS) {
+	    usbd_caps_speed(&test_usbd) >= USBD_SPEED_HS) {
 		err = usbd_add_configuration(&test_usbd, USBD_SPEED_HS, &test_hs_config);
 		zassert_equal(err, 0, "Failed to add configuration (%d)", err);
 	}
@@ -411,6 +420,18 @@ static void *usb_test_enable(void)
 		zassert_equal(err, 0, "Failed to register loopback_0 class (%d)", err);
 	}
 
+	if (USBD_SUPPORTS_SUPER_SPEED &&
+	    usbd_caps_speed(&test_usbd) >= USBD_SPEED_SS) {
+		err = usbd_register_all_classes(&test_usbd, USBD_SPEED_SS, 1, NULL);
+		zassert_equal(err, 0, "Failed to unregister all instances(%d)");
+
+		err = usbd_unregister_all_classes(&test_usbd, USBD_SPEED_SS, 1);
+		zassert_equal(err, 0, "Failed to unregister all instances(%d)");
+
+		err = usbd_register_class(&test_usbd, "loopback_0", USBD_SPEED_SS, 1);
+		zassert_equal(err, 0, "Failed to register loopback_0 class (%d)");
+	}
+
 	err = usbd_register_all_classes(&test_usbd, USBD_SPEED_FS, 1, NULL);
 	zassert_equal(err, 0, "Failed to unregister all instances(%d)", err);
 
-- 
2.47.2

